<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diferencias entre Codigos</title>
    <link rel="stylesheet" type="text/css" href="./estilos.css" />
</head>

<body>
    <div class="contenedor-texto">
        <h1>Relación entre Software y Hardware</h1>

            <p>La relación entre software y hardware es fundamental en el ámbito de los sistemas informáticos. Ambos elementos son complementarios y trabajan juntos para garantizar el funcionamiento eficaz de cualquier dispositivo computacional.</p>
            <ul>
                <li>
                    <strong>Dependencia Mutua:</strong> El hardware proporciona los recursos físicos que permiten la ejecución del software, mientras que el software controla el hardware mediante instrucciones específicas.
                </li>
                <li>
                    <strong>Comunicación a través del Sistema Operativo:</strong> El sistema operativo actúa como un puente entre hardware y software, gestionando los recursos físicos y permitiendo la interacción entre ambos.
                </li>
                <li>
                    <strong>Ejemplo Práctico:</strong> En un teléfono móvil, el hardware incluye componentes como el procesador y la pantalla táctil, mientras que el software permite interactuar con estos elementos para realizar tareas.
                </li>
                <li>
                    <strong>Interdependencia en el Diseño:</strong> El diseño del hardware está influenciado por los requisitos del software que ejecutará, como en el caso de aplicaciones que requieren procesamiento gráfico avanzado.
                </li>
                <li>
                    <strong>Tipos de Software:</strong>
                    <ul>
                        <li><strong>Software de Sistema:</strong> Relacionado directamente con el hardware, gestiona operaciones básicas como el sistema operativo.</li>
                        <li><strong>Software de Aplicación:</strong> Utiliza el hardware a través del sistema operativo para cumplir necesidades específicas del usuario.</li>
                        <li><strong>Firmware:</strong> Combina software y hardware, controlando funciones básicas del hardware.</li>
                    </ul>
                </li>
                <li>
                    <strong>Eficiencia y Optimización:</strong> Un software optimizado aprovecha mejor las capacidades del hardware, mientras que un software ineficiente puede limitar el rendimiento.
                </li>
            </ul>
            

        <h2>Diferencias entre los tipos de Códigos</h2>

       

        <div id="codigoFuente">
            <h3> 1. Código Fuente</h3>

            <p>Es el conjunto de instrucciones escritas en un lenguaje de programación de alto nivel (como
                Python, Java, C++) que los humanos pueden leer y entender fácilmente.</p>
            <p>Características:</p>
            <p>Contiene la lógica del programa expresada en un lenguaje sintáctico y semántico entendible por los
                programadores. Necesita ser traducido para que la máquina pueda ejecutarlo.</p>
            <p>Un ejemplo de estos pueden ser Python, Java o C++</p>

        </div>

        <div id="codigoObj">
            <h3>2. Código Objeto</h3>
            <p>Es el resultado intermedio que se obtiene después de traducir el código fuente mediante un compilador.
                Está en un formato de bajo nivel (lenguaje máquina) que la computadora entiende parcialmente.</p>
            <p>Características:</p>
            <p>No es ejecutable por sí mismo, ya que carece de ciertas referencias, como librerías externas.
                Es específico para una arquitectura de hardware y sistema operativo.</p>
        </div>

        <div id="codigoEje">
            <h3>3. Código Ejecutable</h3>
            <p>Es el archivo final que resulta después de enlazar el código objeto y las librerías necesarias,
                convirtiéndolo en un programa completamente funcional.</p>
            <p>Características:</p>
            <p>Es directamente entendible por el procesador y puede ejecutarse en un sistema operativo específico.
                Normalmente tiene extensiones como .exe (Windows) o sin extensión específica (Linux/Unix).</p>

        </div>

        <div id="traductores">
            <h3>Tipos de Traductores</h3>
            <p>Los traductores son herramientas que convierten el código fuente a un
                 formato ejecutable o interpretable por la máquina.</p>

           <h4>Los principales tipos son:</h4>

            <div id="Compiladores">
                <h4>a) Compiladores:</h4>
                <p>Función: Convierte el código fuente completo en código objeto o ejecutable en un solo paso.</p>
                <p>Ventajas:</p>
                <p> Genera programas rápidos y optimizados.</p>
                <p>No requiere la presencia del compilador para ejecutar el programa.</p>

            </div>
            <div id="interpretes">
                <h4>b) Intérpretes</h4>
                <p>Función: Traduce y ejecuta el código fuente línea por línea, sin generar un archivo intermedio.</p>
                <p>Ventajas:</p>
                <p>Facilita la depuración porque permite observar errores en tiempo real.</p>
                <p>Ideal para desarrollo y pruebas.</p>
                <p>Ejemplo: Python, Ruby.</p>
            </div>

            <div id="Ensambladores">
                <h4>c) Ensambladores</h4>
                <p>Función: Traduce programas escritos en lenguaje ensamblador (cercano al lenguaje máquina) a código
                    objeto.</p>
                <p>Ventajas:</p>
                <p>Permite un control muy preciso del hardware.</p>
                <p>Ejemplo: NASM, MASM.</p>
            </div>

            <div id="Enlazadores">
                <h4>d) Enlazadores</h4>
                <p>Función: Combina múltiples archivos de código objeto y librerías para generar el código ejecutable
                final.</p>
                <p>Ventajas:</p>
                <p>Resuelve referencias externas para crear un programa funcional.</p>
                <p>Ejemplo: ld (Linker de GNU).</p>
                <p>Con estos conceptos claros, puedes entender mejor cómo se transforma un programa desde
                     su creación hasta su ejecución.</p>
            </div>
        </div>

        
        <div id="lengprogramación">
            <h3>1. Lenguajes de bajo nivel</h3>

            <h4><strong>Lenguaje máquina</strong></h4>
            <p>
                Este lenguaje de programación es el más antiguo que existe. El lenguaje máquina es el único que comprenden los
                ordenadores.
                Cualquier código redactado mediante lenguajes alternativos debe ser convertido a lenguaje máquina para
                que un ordenador pueda leerlo.
            </p>
            <p>
                El lenguaje máquina se basa en el código binario, es decir, se escribe a base de 0 y 1. Aprender
                lenguaje máquina es algo muy complejo y no es útil para la creación de programas o webs.
                Es por esto que se han creado los demás lenguajes de bajo nivel, para poder redactar código de manera
                sencilla que puede ser convertido en lenguaje máquina a través de un ensamblador.
            </p>

            <h4><strong>Lenguaje ensamblador</strong></h4>
            <p>
                Los lenguajes de bajo nivel están muy relacionados con el lenguaje máquina. Ambos tipos de lenguaje
                tienen como objetivo ser comprendidos por un ordenador.
                La única diferencia es que los lenguajes ensambladores están hechos para ser escritos por humanos de
                manera sencilla.
                Pese a esto, tiene que ser traducido por un programa conocido como Ensamblador para que los ordenadores
                puedan comprenderlo.
            </p>
            <p>
                En definitiva, el lenguajes ensamblador tiene las mismas funciones que el lenguajes máquina, pero está
                diseñado para poder ser escrito y comprendido con facilidad por los humanos.
                Los códigos son mucho más cortos e intuitivos y, además, tienden a ocupar mucho menos memoria.
            </p>

            <h3>2. Lenguajes de medio nivel</h3>
            <p>
                Los lenguajes de nivel medio tienden a ser clasificados como lenguajes de bajo nivel porque siguen
                dependiendo de ensambladores para poder ser comprendidos por los ordenadores.
                Pese a esto, permiten llevar a cabo tareas mucho más complejas que los lenguajes de bajo nivel como el
                uso de funciones.
                Aun así, muchas tareas deben ser llevadas a cabo de manera manual, aunque hay que destacar que permiten
                los algoritmos de búsqueda y ordenamiento a diferencia de otros lenguajes de alto nivel.
            </p>
            <p>
                En ese sentido, los lenguajes de medio nivel están orientados hacia la programación de sistemas, por lo
                que no son adecuados para tareas como el diseño web.
                Los lenguajes de medio nivel más conocidos son C y C++.
            </p>

            <h3>3. Lenguajes de alto nivel</h3>
            <p>
                Los lenguajes de alto nivel son los más adaptados al lenguaje humano, por lo que son los más sencillos
                de aprender en términos generales.
                Como los de medio nivel, tienen que ser traducidos a lenguaje máquina para poder ser ejecutados por un
                ordenador.
                Pese a esto, debido a las modificaciones del lenguaje en relación al código máquina, los ensambladores
                no son útiles para esto.
                Los lenguajes de alto nivel se adaptan al código máquina a través de traductores y compiladores,
                dependiendo de si se requiere una ejecución más rápida o menos.
            </p>
            <h1>Ingeniería del Software</h1>
            <p>
                Actualmente, la gran mayoría de lenguajes de programación existentes son de alto nivel, a excepción de C y
                C++.
                A continuación te dejamos los lenguajes de programación más utilizados que existen y una breve explicación de
                sus usos:
            </p>

            <div>
                <h2>Fases de Desarrollo de una Aplicación Informática</h2>
        
                <h3>1. Análisis de Requisitos</h3>
                <ul>
                    <li><strong>Objetivo:</strong> Identificar las necesidades del cliente y los objetivos del sistema.</li>
                    <li><strong>Actividades:</strong>
                        <ul>
                            <li>Reuniones con stakeholders para recopilar requisitos.</li>
                            <li>Documentación de requisitos funcionales y no funcionales.</li>
                            <li>Creación de diagramas de casos de uso.</li>
                        </ul>
                    </li>
                    <li><strong>Resultado:</strong> Documento de especificación de requisitos.</li>
                </ul>
        
                <h3>2. Diseño del Sistema</h3>
                <ul>
                    <li><strong>Objetivo:</strong> Planificar la arquitectura y el diseño técnico del sistema.</li>
                    <li><strong>Actividades:</strong>
                        <ul>
                            <li>Diseño de la arquitectura del software (estructurado o por capas).</li>
                            <li>Creación de diagramas UML (clases, secuencias, etc.).</li>
                            <li>Diseño de la interfaz de usuario.</li>
                        </ul>
                    </li>
                    <li><strong>Resultado:</strong> Modelos y diagramas que guían el desarrollo.</li>
                </ul>
        
                <h3>3. Desarrollo o Implementación</h3>
                <ul>
                    <li><strong>Objetivo:</strong> Construir el software basado en los diseños previos.</li>
                    <li><strong>Actividades:</strong>
                        <ul>
                            <li>Codificación de módulos y componentes.</li>
                            <li>Uso de control de versiones (como Git) para gestionar cambios.</li>
                            <li>Integración progresiva de los módulos.</li>
                        </ul>
                    </li>
                    <li><strong>Resultado:</strong> Software funcional inicial.</li>
                </ul>
        
                <h3>4. Pruebas (Testing)</h3>
                <ul>
                    <li><strong>Objetivo:</strong> Garantizar la calidad y el correcto funcionamiento del software.</li>
                    <li><strong>Actividades:</strong>
                        <ul>
                            <li>Pruebas unitarias: Validar componentes individuales.</li>
                            <li>Pruebas de integración: Verificar interacción entre módulos.</li>
                            <li>Pruebas funcionales: Asegurar que cumple los requisitos.</li>
                            <li>Pruebas de rendimiento y seguridad.</li>
                        </ul>
                    </li>
                    <li><strong>Resultado:</strong> Informe de calidad y software listo para producción.</li>
                </ul>
        
                <h3>5. Despliegue (Deployment)</h3>
                <ul>
                    <li><strong>Objetivo:</strong> Poner el software en un entorno de producción accesible para los usuarios finales.</li>
                    <li><strong>Actividades:</strong>
                        <ul>
                            <li>Configuración de servidores.</li>
                            <li>Instalación y configuración del sistema.</li>
                            <li>Capacitación del usuario final.</li>
                        </ul>
                    </li>
                    <li><strong>Resultado:</strong> Software operativo en el entorno del cliente.</li>
                </ul>
        
                <h3>6. Mantenimiento</h3>
                <ul>
                    <li><strong>Objetivo:</strong> Asegurar que el sistema funcione correctamente a lo largo del tiempo.</li>
                    <li><strong>Actividades:</strong>
                        <ul>
                            <li>Corrección de errores reportados por los usuarios.</li>
                            <li>Actualización para adaptarse a nuevos requisitos.</li>
                            <li>Optimización de rendimiento.</li>
                        </ul>
                    </li>
                    <li><strong>Resultado:</strong> Software actualizado y funcional.</li>
                </ul>
            </div>
            <div>
                <h2>Perfiles que Intervienen en el Desarrollo de Software</h2>
        
                <h3>1. Perfiles Gerenciales</h3>
                <ul>
                    <li><strong>Product Owner:</strong> Representa al cliente o usuario final, define y prioriza los requisitos.</li>
                    <li><strong>Project Manager (PM):</strong> Planifica, organiza y supervisa el proyecto, gestionando recursos, tiempo y riesgos.</li>
                </ul>
        
                <h3>2. Perfiles Técnicos</h3>
                <ul>
                    <li><strong>Arquitecto de Software:</strong> Diseña la arquitectura del sistema y toma decisiones técnicas clave.</li>
                    <li><strong>Desarrolladores:</strong>
                        <ul>
                            <li><strong>Frontend Developer:</strong> Encargado de la interfaz de usuario (HTML, CSS, JavaScript, etc.).</li>
                            <li><strong>Backend Developer:</strong> Implementa la lógica del servidor, bases de datos y APIs.</li>
                            <li><strong>Full-Stack Developer:</strong> Trabaja tanto en el frontend como en el backend.</li>
                        </ul>
                    </li>
                    <li><strong>Ingeniero de Pruebas (QA):</strong> Diseña y ejecuta pruebas para garantizar la calidad del software.</li>
                    <li><strong>DevOps:</strong> Gestiona el despliegue y la integración continua, automatizando procesos.</li>
                </ul>
        
                <h3>3. Perfiles Especializados</h3>
                <ul>
                    <li><strong>Analista de Requisitos:</strong> Identifica y documenta las necesidades del cliente.</li>
                    <li><strong>Diseñador UX/UI:</strong> Diseña la experiencia de usuario y la interfaz del software.</li>
                    <li><strong>Ingeniero de Seguridad:</strong> Garantiza que el software sea seguro frente a vulnerabilidades.</li>
                    <li><strong>Científico de Datos (Data Scientist):</strong> Analiza grandes volúmenes de datos para extraer información útil.</li>
                </ul>
        
                <h3>4. Perfiles de Soporte y Mantenimiento</h3>
                <ul>
                    <li><strong>Soporte Técnico:</strong> Atiende dudas y problemas reportados por los usuarios.</li>
                    <li><strong>Ingeniero de Mantenimiento:</strong> Realiza actualizaciones y corrige errores en el software.</li>
                </ul>
        
            </div>
            <div>
                <h2>Modelos de Ciclo de Vida del Software</h2>
        
                <h3>1. Modelo en Cascada</h3>
                <ul>
                    <li><strong>Descripción:</strong> Modelo lineal y secuencial. Cada fase comienza solo después de que la anterior haya sido completada.</li>
                    <li><strong>Fases:</strong>
                        <ul>
                            <li>Requisitos</li>
                            <li>Diseño</li>
                            <li>Implementación</li>
                            <li>Pruebas</li>
                            <li>Mantenimiento</li>
                        </ul>
                    </li>
                    <li><strong>Ventajas:</strong> Simple y fácil de entender.</li>
                    <li><strong>Desventajas:</strong> No se adapta bien a cambios durante el desarrollo.</li>
                </ul>
        
                <h3>2. Modelo Incremental</h3>
                <ul>
                    <li><strong>Descripción:</strong> El desarrollo se realiza en incrementos, cada uno de los cuales entrega una parte del sistema funcional.</li>
                    <li><strong>Fases:</strong>
                        <ul>
                            <li>Repetición cíclica de análisis.</li>
                            <li>Diseño</li>
                            <li>Implementación</li>
                            <li>Pruebas</li>
                        </ul> 
                    </li>
                    <li><strong>Ventajas:</strong> Permite entregas parciales útiles al cliente.</li>
                    <li><strong>Desventajas:</strong> Puede ser difícil definir el alcance de cada incremento.</li>
                </ul>
        
                <h3>3. Modelo en Espiral</h3>
                <ul>
                    <li><strong>Descripción:</strong> Combina características del modelo en cascada con iteraciones y gestión de riesgos.</li>
                    <li><strong>Fases:</strong>
                        <ul>
                            <li>Identificación de objetivos</li>
                            <li>Análisis de riesgos</li>
                            <li>Desarrollo e implementación</li>
                            <li>Evaluación</li>
                        </ul>
                    </li>
                    <li><strong>Ventajas:</strong> Útil para proyectos complejos y de alto riesgo.</li>
                    <li><strong>Desventajas:</strong> Costoso y complejo de gestionar.</li>
                </ul>
        
                <h3>4. Modelo Agil</h3>
                <ul>
                    <li><strong>Descripción:</strong> Basado en iteraciones cortas llamadas sprints, con entregas constantes de valor.</li>
                    <li><strong>Fases:</strong>
                        <ul>
                            <li>Planificación</li>
                            <li>Diseño</li>
                            <li>Desarrollo</li>
                            <li>Pruebas</li>
                            <li>Revisión</li>
                        </ul>
                    </li>
                    <li><strong>Ventajas:</strong> Flexible y permite adaptarse a cambios en los requisitos.</li>
                    <li><strong>Desventajas:</strong> Requiere alta comunicación y colaboración.</li>
                </ul>
        
            </div>

        </div>

        <a href="./index.html" class="btnbck">INICIO</a>
</body>

</html>